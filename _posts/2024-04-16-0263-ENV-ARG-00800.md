---
layout: article
---

Ок, но всё же, управлять большими файлами описания сборок, если там много стадий и параметров, гораздо удобнее, если значения этих `ARG`-инструкций не хардкодить в Dockerfile. 

Docker позволяет нам передавать значения в сборку через командную строку при помощи параметра `--build-arg`. Вот здесь пример Dockerfile, где мы ставим в образ нужную версию `k3s`.

```
FROM alpine:3.19

ARG k3s_version=${k3s_version}

RUN echo  "http://dl-cdn.alpinelinux.org/alpine/edge/testing"  >>  /etc/apk/repositories   	      \
    		&&  apk  update  									                                  \
    		&&  apk  add  --no-cache  openssl  ca-certificates  wget                              \
    		&&  wget  https://github.com/k3s-io/k3s/releases/download/v${k3s_version}%2Bk3s1/k3s  \
    		&&  mv  k3s  /usr/bin/k3s  &&  chmod  +x  /usr/bin/k3s
```

Инструкция ARG получает свое значение из командной строки, а ранее мы экспортировали ее значение `1.28.1` в переменную окружения оболочки хоста.

```
export k3s_version="1.28.1"
```

```
docker image build --build-arg k3s_version="${k3s_version}" .
```

Теперь аргумент сборки, указанный в инструкции ARG получит актуальное значение и использует его в Dockerfile. Если потребуется, то мы можем присвоить значение и для инструкции `ENV`, как мы делали в примере с мультисборкой ранее, т.е. передать его из `ARG` в `ENV`.

Также есть много служебных переменных, которые можно передать через `--build-arg`, которые позволяют тонко настроить работу самого билдера. Например, для настройки прокси или для BuildKit. Это всё есть в документации.
